// lib/models/social_post.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';

enum PostType {
  fitnessProgress,
  nutritionUpdate,
  ecoAchievement,
  reflection,
  milestone,
  weeklyWins,
}

enum PostVisibility {
  public,
  supporters,
  private,
}

enum ReactionType {
  like,
  celebrate,
  boost,
  motivate,
}

enum PostPillar {
  fitness,
  nutrition,
  eco,
}

class SocialPost {
  final String id;
  final String userId;
  final String userName;
  final String? userAvatarUrl;
  final String content;
  final PostType type;
  final List<PostPillar> pillars;
  final List<String> mediaUrls;
  final List<String> videoUrls;
  final PostVisibility visibility;
  final bool autoGenerated;
  final Map<String, dynamic>? sourceData;
  final Map<String, ReactionType> reactions;
  final int commentCount;
  final List<String> tags;
  final DateTime timestamp;
  final DateTime? editedAt;

  SocialPost({
    required this.id,
    required this.userId,
    required this.userName,
    this.userAvatarUrl,
    required this.content,
    required this.type,
    required this.pillars,
    required this.mediaUrls,
    required this.videoUrls,
    required this.visibility,
    required this.autoGenerated,
    this.sourceData,
    required this.reactions,
    required this.commentCount,
    required this.tags,
    required this.timestamp,
    this.editedAt,
  });

  // Create from Firestore document
  factory SocialPost.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    
    return SocialPost(
      id: doc.id,
      userId: data['userId'] ?? '',
      userName: data['userName'] ?? '',
      userAvatarUrl: data['userAvatarUrl'],
      content: data['content'] ?? '',
      type: PostType.values.firstWhere(
        (e) => e.toString() == data['type'],
        orElse: () => PostType.reflection,
      ),
      pillars: (data['pillars'] as List<dynamic>?)
          ?.map((p) => PostPillar.values.firstWhere(
                (e) => e.toString() == p,
                orElse: () => PostPillar.fitness,
              ))
          .toList() ?? [],
      mediaUrls: List<String>.from(data['mediaUrls'] ?? []),
      videoUrls: List<String>.from(data['videoUrls'] ?? []),
      visibility: PostVisibility.values.firstWhere(
        (e) => e.toString() == data['visibility'],
        orElse: () => PostVisibility.supporters,
      ),
      autoGenerated: data['autoGenerated'] ?? false,
      sourceData: data['sourceData'],
      reactions: Map<String, ReactionType>.from(
        (data['reactions'] as Map<String, dynamic>?)?.map(
          (key, value) => MapEntry(
            key,
            ReactionType.values.firstWhere(
              (e) => e.toString() == value,
              orElse: () => ReactionType.like,
            ),
          ),
        ) ?? {},
      ),
      commentCount: data['commentCount'] ?? 0,
      tags: List<String>.from(data['tags'] ?? []),
      timestamp: (data['timestamp'] as Timestamp).toDate(),
      editedAt: data['editedAt'] != null 
          ? (data['editedAt'] as Timestamp).toDate() 
          : null,
    );
  }

  // Convert to Firestore document
  Map<String, dynamic> toFirestore() {
    return {
      'userId': userId,
      'userName': userName,
      'userAvatarUrl': userAvatarUrl,
      'content': content,
      'type': type.toString(),
      'pillars': pillars.map((p) => p.toString()).toList(),
      'mediaUrls': mediaUrls,
      'videoUrls': videoUrls,
      'visibility': visibility.toString(),
      'autoGenerated': autoGenerated,
      'sourceData': sourceData,
      'reactions': reactions.map((key, value) => MapEntry(key, value.toString())),
      'commentCount': commentCount,
      'tags': tags,
      'timestamp': Timestamp.fromDate(timestamp),
      'editedAt': editedAt != null ? Timestamp.fromDate(editedAt!) : null,
    };
  }

  // Helper methods
  bool get hasMedia => mediaUrls.isNotEmpty || videoUrls.isNotEmpty;
  int get totalReactions => reactions.length;
  
  bool hasUserReacted(String userId) => reactions.containsKey(userId);
  ReactionType? getUserReaction(String userId) => reactions[userId];

  // Get pillar display info
  String get pillarDisplayText {
    if (pillars.isEmpty) return '';
    return pillars.map((p) => _getPillarDisplayName(p)).join(' â€¢ ');
  }

  String _getPillarDisplayName(PostPillar pillar) {
    switch (pillar) {
      case PostPillar.fitness:
        return 'Fitness';
      case PostPillar.nutrition:
        return 'Nutrition';
      case PostPillar.eco:
        return 'Eco';
    }
  }

  // Get pillar colors
  List<Color> get pillarColors {
    return pillars.map((p) => _getPillarColor(p)).toList();
  }

  Color _getPillarColor(PostPillar pillar) {
    switch (pillar) {
      case PostPillar.fitness:
        return const Color(0xFF2196F3); // Blue
      case PostPillar.nutrition:
        return const Color(0xFF4CAF50); // Green
      case PostPillar.eco:
        return const Color(0xFF8BC34A); // Light Green
    }
  }

  // Copy with method for updates
  SocialPost copyWith({
    String? id,
    String? userId,
    String? userName,
    String? userAvatarUrl,
    String? content,
    PostType? type,
    List<PostPillar>? pillars,
    List<String>? mediaUrls,
    List<String>? videoUrls,
    PostVisibility? visibility,
    bool? autoGenerated,
    Map<String, dynamic>? sourceData,
    Map<String, ReactionType>? reactions,
    int? commentCount,
    List<String>? tags,
    DateTime? timestamp,
    DateTime? editedAt,
  }) {
    return SocialPost(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      userName: userName ?? this.userName,
      userAvatarUrl: userAvatarUrl ?? this.userAvatarUrl,
      content: content ?? this.content,
      type: type ?? this.type,
      pillars: pillars ?? this.pillars,
      mediaUrls: mediaUrls ?? this.mediaUrls,
      videoUrls: videoUrls ?? this.videoUrls,
      visibility: visibility ?? this.visibility,
      autoGenerated: autoGenerated ?? this.autoGenerated,
      sourceData: sourceData ?? this.sourceData,
      reactions: reactions ?? this.reactions,
      commentCount: commentCount ?? this.commentCount,
      tags: tags ?? this.tags,
      timestamp: timestamp ?? this.timestamp,
      editedAt: editedAt ?? this.editedAt,
    );
  }
}

// Comment model for future use
class PostComment {
  final String id;
  final String postId;
  final String userId;
  final String userName;
  final String? userAvatarUrl;
  final String content;
  final String? mediaUrl;
  final String? parentCommentId;
  final Map<String, ReactionType> reactions;
  final DateTime timestamp;

  PostComment({
    required this.id,
    required this.postId,
    required this.userId,
    required this.userName,
    this.userAvatarUrl,
    required this.content,
    this.mediaUrl,
    this.parentCommentId,
    required this.reactions,
    required this.timestamp,
  });

  factory PostComment.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    
    return PostComment(
      id: doc.id,
      postId: data['postId'] ?? '',
      userId: data['userId'] ?? '',
      userName: data['userName'] ?? '',
      userAvatarUrl: data['userAvatarUrl'],
      content: data['content'] ?? '',
      mediaUrl: data['mediaUrl'],
      parentCommentId: data['parentCommentId'],
      reactions: Map<String, ReactionType>.from(
        (data['reactions'] as Map<String, dynamic>?)?.map(
          (key, value) => MapEntry(
            key,
            ReactionType.values.firstWhere(
              (e) => e.toString() == value,
              orElse: () => ReactionType.like,
            ),
          ),
        ) ?? {},
      ),
      timestamp: (data['timestamp'] as Timestamp).toDate(),
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'postId': postId,
      'userId': userId,
      'userName': userName,
      'userAvatarUrl': userAvatarUrl,
      'content': content,
      'mediaUrl': mediaUrl,
      'parentCommentId': parentCommentId,
      'reactions': reactions.map((key, value) => MapEntry(key, value.toString())),
      'timestamp': Timestamp.fromDate(timestamp),
    };
  }
}
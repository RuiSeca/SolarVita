// lib/services/firebase_social_posts_service.dart

import 'dart:async';
import 'dart:io';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:uuid/uuid.dart';
import '../models/social_post.dart';
import '../models/post_revision.dart';

class FirebaseSocialPostsService {
  static final FirebaseSocialPostsService _instance = FirebaseSocialPostsService._internal();
  factory FirebaseSocialPostsService() => _instance;
  FirebaseSocialPostsService._internal();

  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final FirebaseStorage _storage = FirebaseStorage.instance;
  final Uuid _uuid = const Uuid();

  String? get currentUserId => _auth.currentUser?.uid;
  User? get currentUser => _auth.currentUser;

  /// Create a new social post
  Future<SocialPost> createPost({
    required String content,
    required List<PostPillar> pillars,
    required PostVisibility visibility,
    required PostType type,
    List<File>? mediaFiles,
    List<File>? videoFiles,
    List<String>? tags,
    bool autoGenerated = false,
    String? templateId,
    Map<String, dynamic>? templateData,
  }) async {
    if (currentUserId == null) {
      throw Exception('User must be authenticated to create posts');
    }

    final user = currentUser!;
    final postId = _uuid.v4();
    
    try {
      // Upload media files if provided
      final mediaUrls = <String>[];
      final videoUrls = <String>[];

      if (mediaFiles != null && mediaFiles.isNotEmpty) {
        mediaUrls.addAll(await _uploadMediaFiles(postId, mediaFiles, 'images'));
      }

      if (videoFiles != null && videoFiles.isNotEmpty) {
        videoUrls.addAll(await _uploadMediaFiles(postId, videoFiles, 'videos'));
      }

      // Create the post object
      final post = SocialPost(
        id: postId,
        userId: currentUserId!,
        userName: user.displayName ?? 'Anonymous User',
        userAvatarUrl: user.photoURL,
        content: content,
        type: type,
        pillars: pillars,
        mediaUrls: mediaUrls,
        videoUrls: videoUrls,
        visibility: visibility,
        autoGenerated: autoGenerated,
        reactions: {},
        commentCount: 0,
        tags: tags ?? [],
        timestamp: DateTime.now(),
        templateId: templateId,
        templateData: templateData,
      );

      // Save to Firestore
      await _firestore.collection('social_posts').doc(postId).set(post.toFirestore());

      // Update user's post count
      await _incrementUserPostCount();

      // Create activity entry
      await _createPostActivity(post);

      return post;
    } catch (e) {
      // Clean up uploaded files if post creation fails
      await _cleanupUploadedFiles(postId);
      rethrow;
    }
  }

  /// Get social posts feed with real-time updates
  Stream<List<SocialPost>> getPostsFeed({
    int limit = 20,
    PostVisibility? visibility,
    List<PostPillar>? pillars,
    String? userId,
  }) {
    Query query = _firestore.collection('social_posts');

    // Apply filters
    if (userId != null) {
      query = query.where('userId', isEqualTo: userId);
    }

    if (visibility != null) {
      query = query.where('visibility', isEqualTo: visibility.name);
    }

    if (pillars != null && pillars.isNotEmpty) {
      query = query.where('pillars', arrayContainsAny: pillars.map((p) => p.name).toList());
    }

    // Order by timestamp
    query = query.orderBy('timestamp', descending: true).limit(limit);

    return query.snapshots().map((snapshot) {
      return snapshot.docs
          .map((doc) => SocialPost.fromFirestore(doc))
          .where(_canViewPost)
          .toList();
    });
  }

  /// Get a specific post by ID
  Future<SocialPost?> getPostById(String postId) async {
    try {
      final doc = await _firestore.collection('social_posts').doc(postId).get();
      if (doc.exists && _canViewPost(SocialPost.fromFirestore(doc))) {
        return SocialPost.fromFirestore(doc);
      }
      return null;
    } catch (e) {
      return null;
    }
  }

  /// Update an existing post
  Future<SocialPost> updatePost({
    required String postId,
    String? content,
    List<PostPillar>? pillars,
    PostVisibility? visibility,
    List<File>? newMediaFiles,
    List<String>? removedMediaUrls,
    List<File>? newVideoFiles,
    List<String>? removedVideoUrls,
    List<String>? tags,
    String? editReason,
  }) async {
    if (currentUserId == null) {
      throw Exception('User must be authenticated to edit posts');
    }

    final postDoc = await _firestore.collection('social_posts').doc(postId).get();
    if (!postDoc.exists) {
      throw Exception('Post not found');
    }

    final existingPost = SocialPost.fromFirestore(postDoc);
    
    // Check if user can edit this post
    if (existingPost.userId != currentUserId) {
      throw Exception('You can only edit your own posts');
    }

    try {
      // Handle media updates
      List<String> updatedMediaUrls = List.from(existingPost.mediaUrls);
      List<String> updatedVideoUrls = List.from(existingPost.videoUrls);

      // Remove deleted media
      if (removedMediaUrls != null) {
        for (final url in removedMediaUrls) {
          updatedMediaUrls.remove(url);
          await _deleteMediaFile(url);
        }
      }

      if (removedVideoUrls != null) {
        for (final url in removedVideoUrls) {
          updatedVideoUrls.remove(url);
          await _deleteMediaFile(url);
        }
      }

      // Upload new media
      if (newMediaFiles != null && newMediaFiles.isNotEmpty) {
        final newUrls = await _uploadMediaFiles(postId, newMediaFiles, 'images');
        updatedMediaUrls.addAll(newUrls);
      }

      if (newVideoFiles != null && newVideoFiles.isNotEmpty) {
        final newUrls = await _uploadMediaFiles(postId, newVideoFiles, 'videos');
        updatedVideoUrls.addAll(newUrls);
      }

      // Create updated post
      final updatedPost = existingPost.copyWith(
        content: content,
        pillars: pillars,
        visibility: visibility,
        mediaUrls: updatedMediaUrls,
        videoUrls: updatedVideoUrls,
        tags: tags,
        editedAt: DateTime.now(),
        isEdited: true,
      );

      // Save updates to Firestore
      await _firestore.collection('social_posts').doc(postId).update(updatedPost.toFirestore());

      // Create revision history
      await _createPostRevision(existingPost, updatedPost, editReason);

      return updatedPost;
    } catch (e) {
      rethrow;
    }
  }

  /// Delete a post
  Future<void> deletePost(String postId) async {
    if (currentUserId == null) {
      throw Exception('User must be authenticated to delete posts');
    }

    final postDoc = await _firestore.collection('social_posts').doc(postId).get();
    if (!postDoc.exists) {
      throw Exception('Post not found');
    }

    final post = SocialPost.fromFirestore(postDoc);
    
    // Check if user can delete this post
    if (post.userId != currentUserId) {
      throw Exception('You can only delete your own posts');
    }

    try {
      // Delete all media files
      for (final url in [...post.mediaUrls, ...post.videoUrls]) {
        await _deleteMediaFile(url);
      }

      // Delete all comments
      await _deletePostComments(postId);

      // Delete revision history
      await _deletePostRevisions(postId);

      // Delete the post
      await _firestore.collection('social_posts').doc(postId).delete();

      // Update user's post count
      await _decrementUserPostCount();
    } catch (e) {
      rethrow;
    }
  }

  /// React to a post
  Future<void> reactToPost(String postId, ReactionType reaction) async {
    if (currentUserId == null) {
      throw Exception('User must be authenticated to react to posts');
    }

    final postRef = _firestore.collection('social_posts').doc(postId);

    await _firestore.runTransaction((transaction) async {
      final doc = await transaction.get(postRef);
      if (!doc.exists) {
        throw Exception('Post not found');
      }

      final post = SocialPost.fromFirestore(doc);
      final updatedReactions = Map<String, ReactionType>.from(post.reactions);

      if (updatedReactions.containsKey(currentUserId!) && 
          updatedReactions[currentUserId!] == reaction) {
        // Remove reaction if same reaction is clicked
        updatedReactions.remove(currentUserId!);
      } else {
        // Add or update reaction
        updatedReactions[currentUserId!] = reaction;
      }

      transaction.update(postRef, {'reactions': _reactionsToFirestore(updatedReactions)});
    });
  }

  /// Save/unsave a post
  Future<void> toggleSavePost(String postId) async {
    if (currentUserId == null) {
      throw Exception('User must be authenticated to save posts');
    }

    final savedPostsRef = _firestore
        .collection('users')
        .doc(currentUserId)
        .collection('saved_posts')
        .doc(postId);

    final doc = await savedPostsRef.get();
    
    if (doc.exists) {
      // Unsave the post
      await savedPostsRef.delete();
    } else {
      // Save the post
      await savedPostsRef.set({
        'postId': postId,
        'savedAt': Timestamp.now(),
      });
    }
  }

  /// Check if a post is saved by current user
  Future<bool> isPostSaved(String postId) async {
    if (currentUserId == null) return false;

    final doc = await _firestore
        .collection('users')
        .doc(currentUserId)
        .collection('saved_posts')
        .doc(postId)
        .get();

    return doc.exists;
  }

  /// Get saved posts
  Stream<List<SocialPost>> getSavedPosts({int limit = 20}) {
    if (currentUserId == null) {
      return Stream.value([]);
    }

    return _firestore
        .collection('users')
        .doc(currentUserId)
        .collection('saved_posts')
        .orderBy('savedAt', descending: true)
        .limit(limit)
        .snapshots()
        .asyncMap((snapshot) async {
      final posts = <SocialPost>[];
      
      for (final doc in snapshot.docs) {
        final postId = doc.data()['postId'] as String;
        final post = await getPostById(postId);
        if (post != null) {
          posts.add(post);
        }
      }
      
      return posts;
    });
  }

  /// Get posts by user with visibility filtering
  Stream<List<SocialPost>> getUserPosts(String userId, {int limit = 20}) {
    Query query = _firestore
        .collection('social_posts')
        .where('userId', isEqualTo: userId)
        .orderBy('timestamp', descending: true)
        .limit(limit);

    return query.snapshots().map((snapshot) {
      return snapshot.docs
          .map((doc) => SocialPost.fromFirestore(doc))
          .where(_canViewPost)
          .toList();
    });
  }

  /// Search posts
  Future<List<SocialPost>> searchPosts({
    required String query,
    List<PostPillar>? pillars,
    PostVisibility? visibility,
    int limit = 20,
  }) async {
    // For better search, you might want to implement Algolia or similar
    // For now, we'll do basic text search on content
    Query firestoreQuery = _firestore.collection('social_posts');

    if (visibility != null) {
      firestoreQuery = firestoreQuery.where('visibility', isEqualTo: visibility.name);
    }

    if (pillars != null && pillars.isNotEmpty) {
      firestoreQuery = firestoreQuery.where('pillars', arrayContainsAny: pillars.map((p) => p.name).toList());
    }

    firestoreQuery = firestoreQuery.orderBy('timestamp', descending: true).limit(limit * 2);

    final snapshot = await firestoreQuery.get();
    final posts = snapshot.docs
        .map((doc) => SocialPost.fromFirestore(doc))
        .where(_canViewPost)
        .where((post) => post.content.toLowerCase().contains(query.toLowerCase()) ||
                        post.tags.any((tag) => tag.toLowerCase().contains(query.toLowerCase())))
        .take(limit)
        .toList();

    return posts;
  }

  /// Get trending posts (posts with most reactions in last 24 hours)
  Future<List<SocialPost>> getTrendingPosts({int limit = 20}) async {
    final yesterday = DateTime.now().subtract(const Duration(days: 1));
    
    final snapshot = await _firestore
        .collection('social_posts')
        .where('timestamp', isGreaterThan: Timestamp.fromDate(yesterday))
        .orderBy('timestamp', descending: true)
        .limit(limit * 3) // Get more to sort by reactions
        .get();

    final posts = snapshot.docs
        .map((doc) => SocialPost.fromFirestore(doc))
        .where(_canViewPost)
        .toList();

    // Sort by reaction count
    posts.sort((a, b) => b.reactions.length.compareTo(a.reactions.length));
    
    return posts.take(limit).toList();
  }

  /// Report a post
  Future<void> reportPost({
    required String postId,
    required String reason,
    String? details,
  }) async {
    if (currentUserId == null) {
      throw Exception('User must be authenticated to report posts');
    }

    final reportId = _uuid.v4();
    final report = {
      'id': reportId,
      'postId': postId,
      'reporterId': currentUserId!,
      'reason': reason,
      'details': details,
      'status': 'pending',
      'createdAt': Timestamp.now(),
    };

    await _firestore.collection('post_reports').doc(reportId).set(report);
  }

  // PRIVATE HELPER METHODS

  /// Upload media files to Firebase Storage
  Future<List<String>> _uploadMediaFiles(String postId, List<File> files, String folder) async {
    final urls = <String>[];
    
    for (int i = 0; i < files.length; i++) {
      final file = files[i];
      final fileName = '${_uuid.v4()}_${i}_${DateTime.now().millisecondsSinceEpoch}';
      final extension = file.path.split('.').last;
      final ref = _storage.ref().child('posts/$postId/$folder/$fileName.$extension');
      
      final uploadTask = ref.putFile(file);
      final snapshot = await uploadTask;
      final downloadUrl = await snapshot.ref.getDownloadURL();
      
      urls.add(downloadUrl);
    }
    
    return urls;
  }

  /// Delete a media file from Firebase Storage
  Future<void> _deleteMediaFile(String url) async {
    try {
      final ref = _storage.refFromURL(url);
      await ref.delete();
    } catch (e) {
      // File might already be deleted or not exist
    }
  }

  /// Clean up uploaded files (used when post creation fails)
  Future<void> _cleanupUploadedFiles(String postId) async {
    try {
      final ref = _storage.ref().child('posts/$postId');
      final result = await ref.listAll();
      
      for (final item in result.items) {
        await item.delete();
      }
      
      for (final prefix in result.prefixes) {
        final subResult = await prefix.listAll();
        for (final item in subResult.items) {
          await item.delete();
        }
      }
    } catch (e) {
      // Ignore cleanup errors
    }
  }

  /// Check if current user can view a post based on visibility settings
  bool _canViewPost(SocialPost post) {
    // User can always see their own posts
    if (post.userId == currentUserId) return true;

    switch (post.visibility) {
      case PostVisibility.public:
        return true;
      case PostVisibility.supporters:
        // TODO: Check if current user is a supporter
        return true; // For now, allow all authenticated users
      case PostVisibility.private:
        return false;
    }
  }

  /// Convert reactions map to Firestore format
  Map<String, String> _reactionsToFirestore(Map<String, ReactionType> reactions) {
    return reactions.map((key, value) => MapEntry(key, value.name));
  }

  /// Create post activity for social feed
  Future<void> _createPostActivity(SocialPost post) async {
    final activityId = _uuid.v4();
    final activity = {
      'id': activityId,
      'userId': post.userId,
      'userName': post.userName,
      'userPhotoURL': post.userAvatarUrl,
      'type': 'post_created',
      'title': 'Shared a ${post.type.name} post',
      'description': post.content.length > 100 
          ? '${post.content.substring(0, 100)}...'
          : post.content,
      'visibility': post.visibility.name,
      'metadata': {
        'postId': post.id,
        'postType': post.type.name,
        'pillars': post.pillars.map((p) => p.name).toList(),
        'hasMedia': post.mediaUrls.isNotEmpty || post.videoUrls.isNotEmpty,
      },
      'createdAt': Timestamp.fromDate(post.timestamp),
      'likes': <String>[],
      'commentsCount': 0,
    };

    await _firestore.collection('activities').doc(activityId).set(activity);
  }

  /// Create post revision for edit history
  Future<void> _createPostRevision(SocialPost oldPost, SocialPost newPost, String? editReason) async {
    final revisionId = _uuid.v4();
    
    // Create content revision if content changed
    if (oldPost.content != newPost.content) {
      final revision = PostRevision.createContentEdit(
        postId: oldPost.id,
        userId: oldPost.userId,
        userName: oldPost.userName,
        previousContent: oldPost.content,
        newContent: newPost.content,
        editReason: editReason,
      );
      
      await _firestore.collection('post_revisions').doc(revisionId).set(revision.toFirestore());
    }

    // Create pillar revision if pillars changed
    if (!_listsEqual(oldPost.pillars, newPost.pillars)) {
      final revision = PostRevision.createPillarEdit(
        postId: oldPost.id,
        userId: oldPost.userId,
        userName: oldPost.userName,
        previousPillars: oldPost.pillars,
        newPillars: newPost.pillars,
        editReason: editReason,
      );
      
      await _firestore.collection('post_revisions').doc('${revisionId}_pillars').set(revision.toFirestore());
    }

    // Create visibility revision if visibility changed
    if (oldPost.visibility != newPost.visibility) {
      final revision = PostRevision.createVisibilityEdit(
        postId: oldPost.id,
        userId: oldPost.userId,
        userName: oldPost.userName,
        previousVisibility: oldPost.visibility,
        newVisibility: newPost.visibility,
        editReason: editReason,
      );
      
      await _firestore.collection('post_revisions').doc('${revisionId}_visibility').set(revision.toFirestore());
    }
  }

  /// Delete all comments for a post
  Future<void> _deletePostComments(String postId) async {
    final snapshot = await _firestore
        .collection('post_comments')
        .where('postId', isEqualTo: postId)
        .get();

    final batch = _firestore.batch();
    for (final doc in snapshot.docs) {
      batch.delete(doc.reference);
    }
    
    await batch.commit();
  }

  /// Delete all revisions for a post
  Future<void> _deletePostRevisions(String postId) async {
    final snapshot = await _firestore
        .collection('post_revisions')
        .where('postId', isEqualTo: postId)
        .get();

    final batch = _firestore.batch();
    for (final doc in snapshot.docs) {
      batch.delete(doc.reference);
    }
    
    await batch.commit();
  }

  /// Increment user's post count
  Future<void> _incrementUserPostCount() async {
    if (currentUserId == null) return;

    final userRef = _firestore.collection('users').doc(currentUserId);
    await _firestore.runTransaction((transaction) async {
      final doc = await transaction.get(userRef);
      if (doc.exists) {
        final currentCount = doc.data()?['postsCount'] ?? 0;
        transaction.update(userRef, {'postsCount': currentCount + 1});
      }
    });
  }

  /// Decrement user's post count
  Future<void> _decrementUserPostCount() async {
    if (currentUserId == null) return;

    final userRef = _firestore.collection('users').doc(currentUserId);
    await _firestore.runTransaction((transaction) async {
      final doc = await transaction.get(userRef);
      if (doc.exists) {
        final currentCount = doc.data()?['postsCount'] ?? 0;
        final newCount = (currentCount - 1).clamp(0, double.infinity).toInt();
        transaction.update(userRef, {'postsCount': newCount});
      }
    });
  }

  /// Helper to compare lists
  bool _listsEqual<T>(List<T> a, List<T> b) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }
}